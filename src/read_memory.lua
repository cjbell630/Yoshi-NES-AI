---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by cb106.
--- DateTime: 2/11/2021 19:31
---

--REQUIRES--

require "util"

--END REQUIRES--


Blocks = {
    NONE = 0,
    GOOMBA = 1,
    PIRANHA = 2,
    BOO = 3,
    BLOOPER = 4,
    TOP_EGG = 5,
    BOTTOM_EGG = 6
}

local function readBytes(address, length)
    local bytes = {}
    for i = 0, length - 1, 1 do
        bytes[i + 1] = memory.readbyte(address + i)
    end
    return bytes
end



--BOARD ClASS--

Board = {}
Board.__index = Board
Board.raw = {
    --[[top   ->  bottom]] --
    { 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 }
}

--TODO: this
function Board:getRow(rowNum)
    return {
        --Board.raw[1],
    }
end

--END BOARD CLASS--

--MEMMAP CLASS--

MemMap = {}
MemMap.__index = MemMap

--[[

╔═════════════════╦═════════════════════╦═══════════════════════════════════════════════════════════════════════════════════════════════════════╗
║     address     ║        length       ║                                              explanation                                              ║
╠═════════════════╬═════════════════════╬═══════════════════════════════════════════════════════════════════════════════════════════════════════╣
║ 0x0440          ║ 1 byte              ║ Represents mario's current position                                                                   ║
║                 ║                     ║ 0, 1, or 2   ----   l -> r                                                                            ║
╠═════════════════╬═════════════════════╬═══════════════════════════════════════════════════════════════════════════════════════════════════════╣
║ 0x0442          ║ 1 byte              ║ Represent's Mario's current animation frame.                                                          ║
║                 ║                     ║ Cycles through whenever he turns, remains constant otherwise                                          ║
║                 ║                     ║                                                                                                       ║
║                 ║                     ║ 0 - forward                                                                                           ║
║                 ║                     ║ 1/2/3 - turning                                                                                       ║
║                 ║                     ║ 4 - backward                                                                                          ║
╠═════════════════╬═════════════════════╬═══════════════════════════════════════════════════════════════════════════════════════════════════════╣
║ 0x045A          ║ 1 byte each         ║ Stores information about what types of blocks are currently falling                                   ║
║ 0x045B          ║                     ║ (xxxA -> xxxD | l -> r column)                                                                        ║
║ 0x045C          ║                     ║ Values are set the frame where the last group are set (which is one "tick" before they start falling) ║
║ 0x045D          ║                     ║ Value is cleared when the block they represent is set/matched                                         ║
║                 ║                     ║                                                                                                       ║
║                 ║                     ║ 0 - empty                                                                                             ║
║                 ║                     ║ 1 - Goomba                                                                                            ║
║                 ║                     ║ 2 - Piranha Plant                                                                                     ║
║                 ║                     ║ 3 - Boo                                                                                               ║
║                 ║                     ║ 4 - Blooper                                                                                           ║
║                 ║                     ║ 5 - Top Egg                                                                                           ║
║                 ║                     ║ 6 - Bottom Egg                                                                                        ║
╠═════════════════╬═════════════════════╬═══════════════════════════════════════════════════════════════════════════════════════════════════════╣
║ 0x0462          ║ 1 byte each         ║ Stores information about blocks falling status                                                        ║
║ 0x0463          ║                     ║ (xxx2 -> xxx5 | l -> r column)                                                                        ║
║ 0x0464          ║                     ║                                                                                                       ║
║ 0x0465          ║                     ║ 0 - no block falling (ie moving, so set to 0 when block stops moving)                                 ║
║                 ║                     ║ 1 - block in column, blocks are stunned (delay between setting prev blocks and dropping new ones)     ║
║                 ║                     ║ 2 - block falling in column                                                                           ║
╠═════════════════╬═════════════════════╬═══════════════════════════════════════════════════════════════════════════════════════════════════════╣
║ 0x0490 - 0x0497 ║ 1 byte each address ║ Stores the currently displayed blocks on the board                                                    ║
║ 0x0499 - 0x04A0 ║                     ║ 0x0490 -> 0x0497 = top -> bottom                                                                      ║
║ 0x04A2 - 0x04A9 ║                     ║ 0x0490 -> 0x04AB = left -> right                                                                      ║
║ 0x04AB - 0x04B2 ║                     ║ Stores the positions from top to bottom, with a 1 byte buffer between each column.                    ║
║                 ║                     ║ Positions only include set pieces (so NOT ones that have 2 for their respective above address)        ║
║                 ║                     ║ Uses same values as falling block addresses                                                           ║
╚═════════════════╩═════════════════════╩═══════════════════════════════════════════════════════════════════════════════════════════════════════╝


]]--

MemMap.addresses = {
    MARIO_POS = 0x0440,
    MARIO_FRAME = 0x0442,
    FALL_TYPES_START = 0x045A,
    FALL_STATUS_START = 0x0462,
    BOARD_START = 0x0490
}

function MemMap:marioPos()
    return memory.readbyte(MemMap.addresses.MARIO_POS)
end

function MemMap:marioFrame()
    return memory.readbyte(MemMap.addresses.MARIO_FRAME)
end

function MemMap:fallingBlocks()
    return readBytes(MemMap.addresses.FALL_TYPES_START, 4)
end

function MemMap:areBlocksFalling()
    return hasValue(readBytes(MemMap.addresses.FALL_STATUS_START, 4), 2)
end

--function MemMap:anyBlocksFalling

--END CLASS--

board = {
    --[[top   ->  bottom]] --
    { 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 }
}

--gets the first block in a column (table) that is not empty, starting from the top
--TODO: change for loop to for each
--TODO: make all these functions just get the column themselves since i never do anything else
function getTopBlock(column)
    --[[for i = 1, 8 do
        if column[i] > 0 then
            return column[i]
        end
    end
    return 0]] --
    for _, v in ipairs(column) do
        if v > 0 then
            return v
        end
    end
    return 0
end

function doColumnsHaveMatch(block)
    return { getTopBlock(board[1]) == block, getTopBlock(board[2]) == block, getTopBlock(board[3]) == block, getTopBlock(board[4]) == block }
end

--gets the amount of blocks in a column (table) that are not empty
--TODO: change for loop to for each
function getColumnSize(column)
    for i = 1, 8 do
        if column[i] > 0 then
            return 9 - i
        end
    end
    return 0
end

function getColumn(columnNumber)
    local columnTable = {}
    for j = 1, 8 do
        columnTable[j] = memory.readbyte(0x0490 + (j - 1) + ((columnNumber - 1) * 9))
    end
    return columnTable
end

--stores every block in the 2d table "board"
--NOTE: 8 per row
--NOTE: 2 byte spacing, figure out what they do
--NOTE: reads properly, but doesn't reload sprites.
--NOTE: Reloads for matches!! ex can force any two blocks to match by rewriting 😈
--NOTE: 0490-0497 controls column 1 top-bottom
--NOTE: 0499-04A0 controls column 2
--NOTE: 04A2-04A9 controls column 3
--NOTE: 04AB-04B2 controls column 4
function readBoard()
    for i = 1, 4 do
        --[[for j = 1, 8 do
            board[i][j] = memory.readbyte(0x0490 + (j - 1) + ((i - 1) * 9))
        end]] --
        board[i] = getColumn(i)
    end
end